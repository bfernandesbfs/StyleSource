// Generated using ThemeSource, by Bruno Fernandes
import Foundation

// swiftlint:disable superfluous_disable_command
// swiftlint:disable file_length

// swiftlint:disable explicit_type_interface identifier_name line_length nesting type_body_length type_name

public protocol Themable {
    associatedtype Obj
    func style(config: Obj)
}

public protocol Configurable { }

extension NSObject: Configurable {}

public struct Configuration<T>: CustomDebugStringConvertible {
    private var configurations: [TypedEntry] = []

    public var debugDescription: String {
        var descriptions: [String] = [
            "\(type(of: self)) - keypath count: \(configurations.count)",
            "----"
        ]

        for config in configurations {
            descriptions.append(config.debugDescription)
        }

        return descriptions.joined(separator: "\n")
    }

    public func applied(on target: T) -> T {
        var target = target
        for config in configurations {
            target = config.closure(target)
        }
        return target
    }

    mutating private func appendConfiguration(_ closure: @escaping (T) -> T, file: String, line: Int, description: String) {

        let entry = TypedEntry(closure: closure, file: file, line: line, debugDescription: description)
        configurations.append(entry)
    }

    fileprivate struct TypedEntry: CustomDebugStringConvertible {
        var closure: (T) -> T
        var file: String
        var line: Int
        var debugDescription: String
    }
}

public extension Configuration where T: AnyObject {
    public func with<U>(_ keyPath: WritableKeyPath<T, U>, setTo value: U, file: String = #file, line: Int = #line) -> Configuration {

        var new = self

        let closure: (T) -> T = { target in
            var target = target
            target[keyPath: keyPath] = value
            return target
        }

        new.appendConfiguration(closure, file: file, line: line, description: makeDescription(keyPath, setTo: value, file: file, line: line))

        return new
    }

    public func with<U>(_ keyPath: WritableKeyPath<T, U?>, setTo value: U, file: String = #file, line: Int = #line) -> Configuration {

        var new = self
        let closure: (T) -> T = { target in
            var target = target
            target[keyPath: keyPath] = value
            return target
        }

        new.appendConfiguration(closure, file: file, line: line, description: makeDescription(keyPath, setTo: value, file: file, line: line))

        return new
    }

    private func makeDescription<U>(_ keyPath: PartialKeyPath<T>, setTo value: U, file: String = #file, line: Int = #line) -> String {

        var debugDescription: String = "\((file as NSString).lastPathComponent) line #\(line): "
        debugDescription += "\(type(of: keyPath).valueType) = \(value)"
        return debugDescription
    }
}

public extension Configurable where Self: AnyObject {
    public func configure(with config: Configuration<Self>) {
        config.apply(on: self)
    }
}

public extension Configuration where T: AnyObject {
    public func apply(on target: T) {
        _=applied(on: target)
    }
}

extension Configurable where Self: AnyObject {

    public func configure<U: Themable>(with theme: U) where U.Obj == Self {
        theme.style(config: self)
    }
}

public enum ThemeStyle {
    {% for item in styles %}
    public enum {{ item.key }}: Themable {
        case {{ item.cases|join:", " }}

        public func style(config: {{ item.className }}) {

            var theme = Configuration<{{ item.className }}>()
            switch self {
            {% for element in item.elements %}
                case .{{ element.key }}:
                    theme = theme
                        {% for style in element.styles %}
                        {% if style.name|hasSuffix:"font" %}
                            .with(\.{{ style.name }}, setTo: ThemeFont.{{ style.data.name }}.font(size: {{ style.data.size }}))
                        {% elif style.name|hasSuffix:"color" %}
                            .with(\.{{ style.name }}, setTo: {{ style.data|colors: }} )
                        {% elif style.name == "layer" %}
                        {% for value in style.data|transform: %}
                            {% if value.name|hasSuffix:"color" %}
                            .with(\.{{style.name }}.{{ value.name }}, setTo: ThemeColor.{{ value.data }}.cgColor)
                            {% else %}
                            .with(\.{{style.name }}.{{ value.name }}, setTo: {{ value.data }})
                            {% endif %}
                        {% endfor %}
                        {% elif style.name|hasSuffix:"inset" %}
                            .with(\.{{ style.name }}, setTo: {{ style.data|inset: }})
                        {% elif style.name == "titleLabel" %}
                        {% for value in style.data|transform: %}
                            {% if value.name|hasSuffix:"font" %}
                            .with(\.{{style.name }}!.{{ value.name }}, setTo: ThemeFont.{{ value.data.name }}.font(size: {{ value.data.size }}))
                            {% elif value.name|hasSuffix:"color" %}
                            .with(\.{{style.name }}!.{{ value.name }}, setTo: ThemeColor.{{ value.data }})
                            {% elif value.name|hasSuffix:"inset" %}
                            .with(\.{{ style.name }}!.{{ value.name }}, setTo: {{ value.data|inset: }})
                            {% else %}
                            .with(\.{{style.name }}!.{{ value.name }}, setTo: {{ value.data }})
                            {% endif %}
                        {% endfor %}
                        {% else %}
                            .with(\.{{ style.name }}, setTo: {{ style.data }})
                        {% endif %}
                        {% endfor %}
            {% endfor %}
            }
            config.configure(with: theme)
        }
    }
    {% endfor %}
}
